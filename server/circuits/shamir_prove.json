{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":7807306937543504996,"abi":{"parameters":[{"name":"shares","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Share","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"array","length":32,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"claimId","type":{"kind":"string","length":36},"visibility":"public"},{"name":"hash","type":{"kind":"field"},"visibility":"public"}],"param_witnesses":{"claimId":[{"start":66,"end":102}],"hash":[{"start":102,"end":103}],"shares":[{"start":0,"end":66}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"5dzRSp1HGIXhe9nHHvxrfTP/zORWSigmMUUQDdEUiuTeq+mOTe0m5bWQQtehOkMYVw5eHnDfH95dvPn0y8+X1+9vbg+vfro/XN28Pb+7vLl++Or+UPuX791+OL9+/PL27vzj3eFVm3V2uLh+d3jVt/757PD+8uri4bv759dnhxqnbnQ/3ejz+Y2Jbyx6o234hk7d2DWON/Zaz2/45I3+dGP5+Y3CNxq+0fENvHnDmze8ecObd7x5x5t3vHnHm3e8ecebd7x5x5t3vHnHm+948x1vvuPNd7z5jjff8eY73nzHm+948x1vPvDmA28+8OYDbz7w5gNvPvDmA28+8OYDbz7x5hNvPvHmE28+8eYTbz7x5hNvPvHmE2++8OYLb77w5gtvvvDmC2++8OYLb77w5gtvrm3jV/Dq2vDs2opfafxK51fw9NoG/yVPfoWvL76++Pri64uvL76++Pri64uvL76++Prm65uvb76++frm65uvb76++frm65uvX3z94usXX7/4+sXXL74+xzpxrRPnOnGvEwc7cbETJztxsxNHO3G1E2c7cbcThztxuROnO3G7E8c7cb0T5ztxvxMHPHHBEyc8ccMTRzxxxRNnPHHHE4c8cckTpzxxyxPHPHHNE+c8cc8TBz1x0RMnPXHTE0c9cdUTZz1x1xOHPXHZE6c9cdsTxz1x3RPnPXHfEwc+ceETJz5x4xNHPnHlE2c+cecThz5x6ROnPnHrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6zO3PnPrM7c+c+sztz5z6ytufcWtr7j1Fbe+4tZX3PqKW19x6ytufcWtr7j1Fbe+4tZX3PqKW19x6ytufcWtr7j1Fbe+4tZX3PqKW19x6ytufcWtr7j1Fbe+4tZX3PqKW19x6ytufcWtr7j1Fbe+esEf4b7gr3Bf8Ge43PqKW19x6ytufcWtr7j1Fbe+4tZX3PqKW19x6ytufcWtr7j1Fbe+4tZX3PrqtPWNfTteGesvv7Gzvx19+M9wPFrzz6Oep46O7q9nx+jfP6zufjys/vgvf/fwVk+Ht9m+PfzlkSPhkTPhkSvgkafN+v/2SCU80gmPrIRHtoRH9oRHJhTPnlA8e0Lx7AnFMxKKZyQUz0gonpFQPCOheEZC8YyE4hkJxTMSimckFM9MKJ6ZUDwzoXhmQvHMhOKZCcUzE4pnJhTPTCiemVA8K6F4VkLxrITiWQnFsxKKZyUUz0oonpVQPCuheFZA8bQtoHjaFlA8bQsonrYFFE/bWsIjA4qnbQHF07aA4mlbQPG0LaF4lFA8SigeJRSPEopHCcWjhOJRQvEooXiUUDxKKB4nFI8TiscJxeOE4nFC8TiheJxQPE4oHicUjxOKpxKKpxKKpxKKpxKKpxKKpxKKpxKKpxKKpxKKpxKKpyUUT0sonpZQPC2heFpC8bSE4mkJxdMSiqclFE9LKJ6eUDw9oXh6QvH0hOLpCcXTE4on4TOX24/8zOWmsY5nm9Y/PNKzff04cM+9/btHzoRHroBH/sjPXP7vHqmERzrhkZXwyHbqkVM63pmlbx/5+uGLX88/Xp6/ubq4fbjw+LNP12/vLm+uj1/e/fbhj588nP0d","file_map":{"28":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n\n    pub fn hash<N>(input: [Field; N], message_size: u64) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<N>(input: [Field; N], in_len: u64, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"46":{"source":"use dep::std::hash::poseidon2;\n\nstruct Share {\n    x: Field,\n    y: [Field; 32]\n}\n\npub fn main(\n    shares: [Share; 2],\n    claimId: pub str<36>, // The claimId encoded to verify the product, used as flag\n    hash: pub Field\n) {\n    let mut secret: [Field; 32] = [0; 32];\n\n    // Reconstruct each secret value independently\n    for i in 0..32 {\n        // Lagrange interpolation for each secret value (simplified for 2 points)\n        let mut term0 = shares[0].y[i];\n        term0 = term0 * (-shares[1].x);\n        term0 = term0 / (shares[0].x - shares[1].x);\n\n        let mut term1 = shares[1].y[i];\n        term1 = term1 * (-shares[0].x);\n        term1 = term1 / (shares[1].x - shares[0].x);\n\n        secret[i] = term0 + term1;\n    }\n\n    let expectedHash = poseidon2::Poseidon2::hash(secret, 32);\n    assert(hash == expectedHash, \"Hash mismatch\");\n}\n","path":"/Users/anoy/Documents/Hackathon Projects/bohemauth-main/circuits/shamir_prove/src/main.nr"}},"names":["main"]}